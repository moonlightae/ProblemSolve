# N개의 문제 중 M개의 문제를 푼다.
# 문제는 아이디어 난이도, 구현 난이도를 가짐.
# 문제를 풀 수 있는 조건
# 1. 아이디어 난이도(D)가 아이디어 능력(d)보다 같거나 작다.
#   - 그 중 구현 난이도(P) > 구현 능력(p)인 경우에는 P - p만큼 틀렸습니다의 개수가 증가한다.
# 2. 문제에 데이터가 존재한다면(T = 1)인 경우에는 틀렸습니다가 증가하지 않는다.
# 3. 문제에 에디토리얼이 존재한다면(E = 1)인 경우에는 다음과 같은 절차를 거친다.
#   - d * 2 >= D이면, D와 P가 모두 //2가 된다.
# 4. 문제를 푼 개수가 1개 증가하면, 아이디어 능력과 구현 능력이 1씩 증가한다.
# 5. 입력된 문제의 특성 순서는 아이디어 난이도, 구현 난이도, 데이터 여부, 에디토리얼 여부이다.

N, M = map(int, input().split())
L = [[] for _ in range(N)]
for i in range(N):
    L[i] = list(map(int, input().split()))
d, p = map(int, input().split())

i = 0
while i <= N:  # 아이디어 난이도가 너무 높은 문제 제외
    main = L.pop(0)
    print(main)
    if main[0] <= d + M:
        L.append(main)
        i += 1

print(L)
